# Pro Git  
***Scott Chacon, Ben Straub.*** 
Версия 2.1.95-2-g8d45587, от 19.01.2022 года.  
[https://git-scm.com/book/ru/v2](https://git-scm.com/book/ru/v2)

**Licence**. Это произведение распространяется по свободной лицензии Creative Commons Attribution- NonCommercial-ShareAlike 3.0.   Ознакомиться с текстом лицензии вы можете на сайте [https://creativecommons.org/licenses/by-nc-sa/3.0/deed.ru](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.ru)  

## Введение
**Система контроля версий** — это система, записывающая изменения в файл или набор файлов в течение времени и позволяющая вернуться позже к определённой версии.

**Локальные системы контроля версий** страдают от проблемы: когда вся история проекта хранится в одном месте, вы рискуете потерять всё.

**Распределённые системы контроля версий**. Здесь в игру вступают распределённые системы контроля версий (РСКВ). В РСКВ (таких как Git, Mercurial, Bazaar или Darcs) клиенты не просто скачивают снимок всех файлов (состояние файлов на определённый момент времени) — они полностью копируют репозиторий. В этом случае, если один из серверов, через который разработчики обменивались данными, умрёт, любой клиентский репозиторий может быть скопирован на другой сервер для продолжения работы. Каждая копия репозитория является полным бэкапом всех данных.

**История Git**. В 2005 году сообщество разработчиков ядра Linux (а в частности Линус Торвальдс — создатель Linux) разработали свою собственную утилиту.

Подход Git к хранению данных больше похож на набор снимков миниатюрной файловой системы. Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён. Git представляет свои данные как, ***поток снимков***.  
Если вы в самолёте или в поезде и хотите немного поработать, вы сможете создавать коммиты без каких-либо проблем (в вашу локальную копию): когда будет возможность подключиться к сети, все изменения можно будет синхронизировать.

В Git для всего вычисляется **хеш-сумма**, и только потом происходит сохранение. В дальнейшем обращение к сохранённым объектам происходит по этой хеш-сумме. Это значит, что невозможно изменить содержимое файла или каталога так, чтобы Git не узнал об этом. Git сохраняет все объекты в свою базу данных не по имени, а по хеш-сумме содержимого объекта.

У Git есть три основных состояния, в которых могут находиться ваши файлы:   
-***Изменён (modified)*** относятся файлы, которые поменялись, но ещё не были зафиксированы.  
-***Индексирован (staged)*** изменённый файл в его текущей версии, отмеченный для включения в следующий коммит.   
-***Зафиксирован (committed)*** файл уже сохранён в вашей локальной базе.

Рабочая копия является снимком одной версии проекта. Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или редактировать.   
**Область индексирования** — это файл, обычно находящийся в каталоге Git, в нём содержится информация о том, что попадёт в следующий коммит. Её техническое название на языке Git — «индекс», но фраза «область индексирования» также работает.
Каталог Git — это то место, где Git хранит метаданные и базу объектов вашего проекта. 

### Установка 
По умолчанию уже стоит в системе, но есть и установка на Mac OS, Windows, Linux, установка напрямую свежей версии из исходников  [https://git-scm.com/download/](https://git-scm.com/download/)   
` git --version ` 

### Первоначальная настройка Git
В состав Git входит утилита git config, которая позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git, а также его внешний вид. Эти параметры могут быть сохранены в трёх местах:   
1. Файл  `[path]/etc/gitconfig` содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске git config указать параметр `--system`, то параметры будут читаться и сохраняться именно в этот файл. Так как этот файл является системным, то вам потребуются права суперпользователя для внесения изменений в него.
2. Файл ` ~/.gitconfig или ~/.config/git/config ` хранит настройки конкретного пользователя. Этот файл используется при указании параметра ` --global ` и применяется ко всем репозиториям, с которыми вы работаете в текущей системе.
3. Файл config в каталоге Git (т. е. ` .git/config `) репозитория, который вы используете в данный момент, хранит настройки конкретного репозитория. Вы можете заставить Git читать и писать в этот файл с помощью параметра ` --local `, но на самом деле это значение по умолчанию. Неудивительно, что вам нужно находиться где-то в репозитории Git, чтобы эта опция работала правильно.   
Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в ` .git/config ` перекрывают соответствующие значения в ` [path]/etc/gitconfig `

Чтобы посмотреть все установленные настройки и узнать где именно они заданы, используйте команду:  

```
git config --list --show-origin
```
 
**Можно указать ваше имя и адрес электронной почты:**

```
git config --global user.name "Name"
git config --global user.email name@example.com
```
Eсли указана опция ` --global `, то эти настройки достаточно сделать только один раз, поскольку в этом случае Git будет использовать эти данные для всего, что вы делаете в этой системе. Если для каких-то отдельных проектов вы хотите указать другое имя или электронную почту, можно выполнить эту же команду без параметра ` --global ` в каталоге с нужным проектом.

Можно выбрать текстовый редактор, который будет использоваться, если будет нужно набрать сообщение в Git. По умолчанию Git использует стандартный редактор вашей системы, обычно Vim. Если вы хотите использовать другой текстовый редактор, например, Emacs, можно проделать следующее:

``` 
git config --global core.editor emacs
```
  
### Настройка ветки по умолчанию
Когда вы инициализируете репозиторий командой git init, Git создаёт ветку с именем master по умолчанию. Вы можете задать другое имя для создания ветки по умолчанию.
Например, чтобы установить имя ` main ` для вашей ветки по умолчанию, выполните следующую команду:

```
git config --global init.defaultBranch main
```
   
Если вы хотите проверить используемую конфигурацию, можете использовать команду ` git config --list `, чтобы показать все настройки, которые Git найдёт:

```
flyboroda@MacBook-Air-Artem ~ % git config --list
credential.helper=osxkeychain
init.defaultbranch=main
user.name=artemiosdev
user.email=name@gmail.com
user.password=********
core.excludesfile=~/.gitignore_global
credential.helper=osxkeychain
credential.username=artemiosdev
alias.last=log -1 HEAD   
```

### Как получить помощь?
Если вам нужна помощь при использовании Git, есть три способа открыть страницу руководства по любой команде Git:

```
git help <команда>
git <команда> --help 
man git-<команда>
```
  
## Основы Git
### Создание репозитория в существующем каталоге.  
Команда создаёт в текущем каталоге новый подкаталог с именем **.git**, содержащий все необходимые файлы репозитория — структуру Git репозитория

``` 
git init
```

Если вы хотите добавить под версионный контроль существующие файлы (в отличие от пустого каталога), вам стоит добавить их в индекс и осуществить первый коммит изменений. Добиться этого вы сможете запустив команду ` git add ` (имеет различные вариации использования). Указав индексируемые файлы, затем выполним ` git commit ` чтобы зафиксировать:

```
git add *.md
git add .
git add <file name>
git commit -m 'Message about commit'
```
Git индексирует файл в точности в том состоянии, в котором он находился, когда вы выполнили команду ` git add `. Команда ` git add ` принимает параметром путь к файлу или каталогу, если это каталог, команда рекурсивно добавляет все файлы из указанного каталога в индекс, это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, для указания файлов с исправленным конфликтом слияния, «добавить этот контент в следующий коммит».

### Клонирование существующего репозитория    

```
git clone 'https://github.com/artemiosdev/ProGit-MyNotes'
```
В Git реализовано несколько транспортных протоколов, которые вы можете использовать. В предыдущем примере использовался протокол ` https:// `, вы также можете встретить ` git:// ` или ` user@server:path/to/repo.git `, использующий протокол передачи **SSH**.

### Определение состояния файлов   
Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда
 
```
git status
```

### Игнорирование файлов   
Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т. п.). В таком случае, вы можете создать файл ` .gitignore `. с перечислением шаблонов соответствующих таким файлам. И при коммите указанные файлы будут проигнорированы. 

Хорошая практика заключается в настройке файла `.gitignore ` до того, как начать серьёзно работать, это защитит вас от случайного добавления в репозиторий файлов, которых вы там видеть не хотите.   
К шаблонам в файле ` .gitignore ` применяются следующие правила:
* Пустые строки, а также строки, начинающиеся с ` # `, игнорируются.
* Стандартные шаблоны являются глобальными и применяются рекурсивно для всего дерева каталогов.
* Чтобы избежать рекурсии используйте символ слеш ` (/) ` в начале шаблона.
* Чтобы исключить каталог добавьте слеш ` (/) ` в конец шаблона.
* Можно инвертировать шаблон, использовав восклицательный знак ` (!) ` в качестве первого символа.

Glob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами. Символ ` (*) ` соответствует 0 или более символам; последовательность ` [abc]  ` — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса ` (?) ` соответствует одному символу; и квадратные скобки, в которые заключены символы, разделённые дефисом ` ([0-9]) `, соответствуют любому символу из интервала (в данном случае от 0 до 9). Вы также можете использовать две звёздочки, чтобы указать на вложенные каталоги: ` a/**/z ` соответствует ` a/z, a/b/z, a/b/c/z, ` и так далее.

Пример файла ` .gitignore `:

```   
# Исключить все файлы с расширение .a
*.a

# Но отслеживать файл lib.a даже если он подпадает под исключение выше 
!lib.a

# Исключить файл TODO в корневом каталоге, но не файл в subdir/TODO 
/TODO

# Игнорировать все файлы в каталоге build/ 
build/

# Игнорировать файл doc/notes.txt, но не файл doc/server/arch.txt 
doc/*.txt

# Игнорировать все .txt файлы в каталоге doc/ 
doc/**/*.txt
```

GitHub поддерживает довольно полный список примеров ` .gitignore   ` файлов для множества проектов и языков [https://github.com/github/gitignore](https://github.com/github/gitignore) 


### Просмотр индексированных и неиндексированных изменений
Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите ` git diff ` без аргументов

Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения.
Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить ` git diff --staged ` (или ` git diff --cached ` для просмотра проиндексированных изменений (` --staged ` и ` --cached ` синонимы)). Эта команда сравнивает ваши проиндексированные изменения с последним коммитом:

```
git diff --staged
 or
git diff --cached
```

` git diff ` сама по себе не показывает все изменения сделанные с последнего коммита — только те, что ещё не проиндексированы. Такое поведение может сбивать с толку, так как если вы проиндексируете все свои изменения, то git diff ничего не вернёт.

### Коммит изменений
Простейший способ зафиксировать изменения — это набрать ` git commit `
Для ещё более подробного напоминания, что же именно вы поменяли, можете передать аргумент `-v` в команду `git commit`. Это приведёт к тому, что в комментарий будет также помещена дельта/diff изменений, таким образом вы сможете точно увидеть все изменения которые вы совершили.
Вы можете набрать свой комментарий к коммиту в командной строке вместе с командой `commit` указав его после параметра `-m`

```
git commit -m "Message about commit"
```

Запомните, что коммит сохраняет снимок состояния вашего индекса. Всё, что вы не проиндексировали, так и висит в рабочем каталоге как изменённое; вы можете сделать ещё один коммит, чтобы добавить эти изменения в репозиторий. Каждый раз, когда вы делаете коммит, вы сохраняете снимок состояния вашего проекта, который позже вы можете восстановить или с которым можно сравнить текущее состояние.

### Пропуск индексации
Если у вас есть желание пропустить этап индексирования (т.е добавления файлов командой `git add`), Git предоставляет простой способ. Добавление параметра `-a` в команду `git commit` заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без `git add`:

```
git commit -a -m 'Message about commit'
```

В данном случае перед коммитом вам не нужно выполнять `git add` для файла, потому что флаг `-a` включает все файлы. Это удобно, но будьте осторожны: флаг `-a` может включить в коммит нежелательные изменения.

### Удаление файлов
Для того чтобы удалить файл из Git, вам необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит. Это позволяет сделать команда `git rm`, которая также удаляет файл из вашего рабочего каталога, так что в следующий раз вы не увидите его как «неотслеживаемый».

Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра `-f`. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git.
Другая полезная штука, которую вы можете захотеть сделать — это удалить файл из индекса, оставив его при этом в рабочем каталоге. Другими словами, вы можете захотеть оставить файл на жёстком диске, но перестать отслеживать изменения в нём. Это особенно полезно, если вы забыли добавить что-то в файл `.gitignore` и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы сделать это, используйте опцию ` --cached`:

```
git rm --cached <file name>
```

В команду `git rm` можно передавать файлы, каталоги или шаблоны. 

```
git rm log/\*.log
```
Обратите внимание на обратный слеш ` \ ` перед ` * `. Он необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику вашего командного интерпретатора. Эта команда удаляет все файлы, имеющие расширение `.log` и находящиеся в каталоге `log/`.    
Или же вы можете сделать вот так:

```
git rm \*~
```
Эта команда удаляет все файлы, имена которых заканчиваются на ` ~ `.

### Перемещение файлов
Команда ` mv ` eсли вам хочется переименовать файл:

```
git mv file_from file_to
```
Однако, это эквивалентно выполнению следующих команд:

```
mv README MyFile
git rm README
git add MyFile
```

### Просмотр истории коммитов
Команда ` git log ` имеет очень большое количество опций для поиска коммитов по разным критериям. Одним из самых полезных аргументов является ` -p ` или ` --patch `, который **показывает разницу** (выводит патч), внесенную в каждый коммит. Так же вы можете ограничить количество записей в выводе команды; используйте параметр ` -2 ` для вывода только двух записей:

```
git log -p -2
```

Если вы хотите увидеть сокращенную статистику для каждого коммита, вы можете использовать опцию ` --stat `:

```
git log --stat
```

Опция ` --stat ` печатает под каждым из коммитов список и количество измененных файлов, а также сколько строк в каждом из файлов было добавлено и удалено. В конце можно увидеть суммарную таблицу изменений.    

Следующей опцией является ` --pretty `. Эта опция меняет формат вывода. Существует несколько встроенных вариантов отображения.

Наиболее интересной опцией является ` format `, которая позволяет указать формат для вывода информации. Особенно это может быть полезным когда вы хотите сгенерировать вывод для автоматического анализа — так как вы указываете формат явно, он не будет изменен даже после обновления Git:

```
git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Artem Androsenko, 1 years ago : Change version number
```

### Полезные опции для ` git log --pretty=format `
`%H` Хеш коммита.   
`%h` Сокращенный хеш коммита.   
`%T` Хеш дерева.   
`%t` Сокращенный хеш дерева.   
`%P` Хеш родителей.   
`%p` Сокращенный хеш родителей.  
`%an` Имя автора.  
`%ae` Электронная почта автора.  
`%ad` Дата автора (формат даты можно задать опцией ` --date=option `).   
`%ar` Относительная дата автора.   
`%cn` Имя коммитера.   
`%ce` Электронная почта коммитера.    
`%cd` Дата коммитера.   
`%cr` Относительная дата коммитера.   
`%s` Содержание.   

Опция ` --graph ` команды ` log `. С этой опцией вы сможете увидеть небольшой граф в формате **ASCII**, который показывает текущую ветку и историю слияний:

```
git log --pretty=format:"%h %s" --graph
  * 2d3acf9 Ignore errors from SIGCHLD on trap
  *  5e3ee11 Merge branch 'master' of git://github.com/artemiosdev/grit
  |\
  | * 420eac9 Add method for getting the current branch
  * | 30e367c Timeout code and tests
  * | e1193f8 Support for heads with slashes in them
  |/
  * d6016bc Require time for xmlschema
  *  11d191e Merge branch 'defunkt' into local
```

### Наиболее распространенные опции для команды `git log`
` -p ` Показывает патч для каждого коммита.     
` --stat ` Показывает статистику измененных файлов для каждого коммита.     
` --shortstat ` Отображает только строку с количеством изменений/вставок/удалений для команды ` --stat `.    
` --name-only ` Показывает список измененных файлов после информации о коммите.     
` --name-status ` Показывает список файлов, которые добавлены/изменены/удалены.     
` --abbrev-commit ` Показывает только несколько символов SHA-1 чек-суммы вместо всех 40.     
` --relative-date ` Отображает дату в относительном формате (например, «2 weeks ago») вместо стандартного формата даты.    
` --graph ` Отображает ASCII граф с ветвлениями и историей слияний.    
` --pretty ` Показывает коммиты в альтернативном формате. Возможные варианты опций: `oneline`, `short`, `full`, `fuller` и `format` (с помощью последней можно указать свой формат).   
` --oneline ` Сокращение для одновременного использования опций ` --pretty=oneline --abbrev-commit `

### Ограничение вывода
В дополнение к опциям форматирования вывода, команда `git log` принимает несколько опций для ограничения вывода — опций, с помощью которых можно увидеть определенное подмножество коммитов. 
Вы можете использовать `-<n> `, где `n` — это любое натуральное число и представляет собой `n` последних коммитов.
Опции для ограничения вывода по времени, такие как ` --since ` и   ` --until `, являются очень удобными. Например, следующая команда покажет список коммитов, сделанных за последние две недели:

```
git log --since=2.weeks
```

Это команда работает с большим количеством форматов — вы можете указать определенную дату вида 2008-01-15 или же относительную дату, например 2 years 1 day 3 minutes ago.

Допускается указывать несколько параметров ` --author ` и ` --grep ` для поиска, которые позволят найти коммиты, соответствующие любому указанному ` --author ` и любому указанному ` --grep ` шаблону; однако, применение опции ` --all-match ` заставит искать коммиты соответствующие всем указанным ` --grep ` шаблонам.

Опция ` -S `, которая принимает аргумент в виде строки и показывает только те коммиты, в которых изменение в коде повлекло за собой добавление или удаление этой строки. Например, если вы хотите найти последний коммит, который добавил или удалил вызов определенной функции, вы можете запустить команду:

```
git log -S function_name
```

**Опция путь**. Если вы укажете каталог или имя файла, вы ограничите вывод только теми коммитами, в которых были изменения этих файлов. Эта опция всегда указывается последней после двойного тире ` (--) `, чтобы отделить пути от опций:

```
git log -- path/to/file
```

###  Опции для ограничения вывода команды `git log`
` -(n) ` Показывает только последние n коммитов.    
` --since `, ` --after ` Показывает только те коммиты, которые были сделаны после указанной даты.     
` --until `, ` --before ` Показывает только те коммиты, которые были сделаны до указанной даты.    
` --author ` Показывает только те коммиты, в которых запись author совпадает с указанной строкой.   
` --committer ` Показывает только те коммиты, в которых запись committer совпадает с указанной строкой.   
` --grep ` Показывает только коммиты, сообщение которых содержит указанную строку.   
` -S ` Показывает только коммиты, в которых изменение в коде повлекло за собой добавление или удаление указанной строки.   

Например, если вы хотите увидеть, в каких коммитах произошли изменения в тестовых файлах в исходном коде Git в октябре 2008 года, автором которых был Junio Hamano и которые не были коммитами слияния, вы можете запустить следующую команду:

```
git log --pretty="%h - %s" --author='Junio C Hamano' --since="2008-10-01" \ --before="2008-11-01" --no-merges -- t/
```

Из почти 40 000 коммитов в истории исходного кода Git, эта команда показывает только 6, которые соответствуют этим критериям.
В зависимости от используемого порядка работы, история коммитов в вашем репозитории может содержать большое количество коммитов слияния, которые сами по себе не очень информативны. Чтобы исключить их из вывода команды `git log` используйте опцию ` --no-merges `

### Операции отмены
Основные способы отмены сделанных изменений. Будьте осторожны, не все операции отмены в свою очередь можно отменить! Это одна из редких областей Git, где неверными действиями можно необратимо удалить результаты своей работы.

Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит — внесите необходимые изменения, добавьте их в индекс и сделайте коммит ещё раз, указав параметр ` --amend `:

```
git commit --amend
```

Например, если вы сделали коммит и поняли, что забыли проиндексировать изменения в файле, который хотели добавить в коммит, то можно сделать следующее:

```
git commit -m 'Initial commit'
git add forgotten_file
git commit --amend
```

В итоге получится единый коммит — второй коммит заменит результаты первого.    
Очень важно понимать, что когда вы вносите правки в последний коммит, вы не столько исправляете его, сколько заменяете новым, который полностью его перезаписывает. В результате всё выглядит так, будто первоначальный коммит никогда не существовал, а так же он больше не появится в истории вашего репозитория.

### Отмена индексации файла
Например, вы изменили два файла и хотите добавить их в разные коммиты, но случайно выполнили команду ` git add * ` и добавили в индекс оба. Как исключить из индекса один из них? Команда `git status` напомнит вам:

```
git add *
git status
  On branch master
  Changes to be committed:
    (use "git reset HEAD <file>..." to unstage)
```
Используйте `git reset HEAD <file> ` для исключения из индекса.

### Отмена изменений в файле
Команда `git status` напомнит вам:

```
   Changes not staged for commit:
   (use "git checkout -- <file>..." to discard changes in working directory)
   
   git checkout -- <file>
```

Важно понимать, что ` git checkout -- <file> ` — опасная команда. Все локальные изменения в файле пропадут — Git просто заменит его версией из последнего коммита. Ни в коем случае не используйте эту команду, если вы не уверены, что изменения в файле вам не нужны.   
Помните, все что попало в коммит почти всегда Git может восстановить. Можно восстановить даже коммиты из веток, которые были удалены, или коммиты, перезаписанные параметром ` --amend ` (см. Восстановление данных). Но всё, что не было включено в коммит и потеряно — скорее всего, потеряно навсегда.


### Отмена действий с помощью git restore
Предположим, что вы изменили два файла и хотите зафиксировать их как два отдельных изменения, но случайно набираете ` git add * ` и индексируете их оба. Как вы можете убрать из индекса один из двух? Команда `git status` напоминает вам:
 
 ```
git add *
git status
  On branch master
  Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
```

Использовать ` git restore --staged <file> ` для отмены индексации файла.     

### Откат измененного файла с помощью `git restore`
Что, если вы поймете, что не хотите сохранять изменения в файле ? Как легко его откатить — вернуть обратно к тому, как он выглядел при последнем коммите (или изначально клонирован, или каким-либо образом помещён в рабочий каталог).    
К счастью, `git status` тоже говорит, как это сделать. В выводе последнего примера, неиндексированная область выглядит следующим образом:

```
  Changes not staged for commit:
    (use "git add <file>..." to update what will be committed)
    (use "git restore <file>..." to discard changes in working directory
    
    git restore <file>
```

Важно понимать, что `git restore <file> ` — опасная команда. Любые локальные изменения, внесенные в этот файл, исчезнут — Git просто заменит файл последней зафиксированной версией. Никогда не используйте эту команду, если точно не знаете, нужны ли вам эти несохраненные локальные изменения.

### Работа с удалёнными репозиториями
### Просмотр удалённых репозиториев
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду `git remote`. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум `origin` — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование:    
`-v`, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:   

```
git remote -v
origin  https://github.com/schacon/ticgit (fetch)
origin  https://github.com/schacon/ticgit (push)
```

### Добавление удалённых репозиториев
Для того, чтобы добавить удалённый репозиторий и присвоить ему имя `(shortname)`, просто выполните команду    

```
git remote add <shortname> <url>
```
Например, если вы хотите получить изменения, которые есть у кого-то, но нету у вас, вы можете выполнить команду `git fetch <shortname>`

### Получение изменений из удалённого репозитория — Fetch и Pull
Как вы только что узнали, для получения данных из удалённых проектов, следует выполнить:

```
git fetch [remote-name]
```
Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.    

Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем `origin`. Таким образом, `git fetch origin` извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью `fetch`). Важно отметить, что команда `git fetch` **забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент**. *Вам необходимо вручную слить эти данные с вашими*, когда вы будете готовы.

### Отправка изменений в удаленный репозиторий (Push)
Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: `git push <remote-name> <branch-name>`. Чтобы отправить вашу ветку main на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:

```
git push origin master
```
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду `push`. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду `push`, а после него выполнить команду push попытаетесь вы, то ваш push точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить `push`.

### Просмотр удаленного репозитория
Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду `git remote show <remote>`. Выполнив эту команду с некоторым именем, например, `origin`, вы получите следующий результат:

```
git remote show origin
```

Она выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда любезно сообщает вам, что если вы, находясь на ветке `main`, выполните `git pull`, ветка `main` с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных. Она также выдаёт список всех полученных ею ссылок.

### Удаление и переименование удалённых репозиториев
Для переименования удалённого репозитория можно выполнить ` git remote rename `. Например, если вы хотите переименовать oldname в newname, вы можете это сделать при помощи git remote rename:

```
git remote rename oldname newname
```

Если  вы хотите удалить удаленный репозиторий — вы сменили сервер или больше не используете определённое зеркало, или кто-то перестал вносить изменения — вы можете использовать ` git remote rm `

```
git remote remove repositoryname
```

При удалении ссылки на удалённый репозиторий все отслеживаемые ветки и настройки, связанные с этим репозиторием, так же будут удалены.

### Работа с тегами
Git имеет возможность помечать определённые моменты в истории как важные. Как правило, эта функциональность используется для отметки моментов выпуска версий (v1.0, и т. п.). Такие пометки в Git называются ***тегами***.

### Просмотр списка тегов
Просмотреть список имеющихся тегов в Git можно очень просто.     Достаточно набрать команду `git tag` (параметры `-l` и ` --list` опциональны)

Поиск тега по шаблону. Например, репозиторий Git содержит много тегов. Если вы хотите посмотреть теги выпусков 1.8.5, то выполните следующую команду:

```
git tag -l "v1.8.5*"
  v1.8.5
  v1.8.5.1
  v1.8.5.2
  v1.8.5.3
```

Если вы хотите отфильтровать список тегов согласно шаблону, использование параметров `-l` или ` --list` становится обязательным.  

### Создание тегов
Git использует два основных типа тегов: ***легковесные и аннотированные***.    
***Легковесный тег*** — это что-то очень похожее на ветку, которая не изменяется — просто указатель на определённый коммит.

***Аннотированные теги*** хранятся в базе данных Git как полноценные объекты. Они имеют контрольную сумму, содержат имя автора, его e-mail и дату создания, имеют комментарий и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG). Обычно рекомендуется создавать аннотированные теги, чтобы иметь всю перечисленную информацию; но если вы хотите сделать временную метку или по какой-то причине не хотите сохранять остальную информацию, то для этого годятся и легковесные.

### Аннотированные теги
Создание аннотированного тега — это указать `-a` при выполнении команды `tag`:

```
git tag -a v1.4 -m "my version 1.4"
git tag
v1.4
```
Опция `-m` задаёт сообщение, которое будет храниться вместе с тегом. Если не указать сообщение, то Git запустит редактор VIM, чтобы его ввести.     
С помощью команды `git show` вы можете посмотреть данные тега вместе с коммитом:

```
git show v1.4
```

### Легковесные теги
**Легковесный тег** — это ещё один способ пометить коммит. По сути, это только контрольная сумма коммита, сохранённая в файл — больше никакой информации не хранится. Для создания легковесного тега не передавайте опций `-a`, `-s` и `-m`, укажите только название:

```
git tag v1.4-lw
```

### Отложенная расстановка тегов
Возможно помечать уже пройденные коммиты. Предположим, история коммитов такова:

```
git log --pretty=oneline
  4682c3261057305bdd616e23b64b0857d832627b Add todo file
  166ae0c4d3f420721acbb115cc33848dfcc2121a Create write support
  9fceb02d0ae598e95dc970b74767f19372d61af8 Update rakefile
```

Теперь предположим, что вы забыли отметить версию проекта v1.2, которая была там, где находится коммит «Update rakefile». Вы можете добавить тег и позже. Для отметки коммита укажите его контрольную сумму (или её часть) как параметр команды:

```
git tag -a v1.2 9fceb02
```

### Обмен тегами
По умолчанию, команда git push не отправляет теги на удалённые сервера. После создания теги нужно отправлять явно на удалённый сервер. Процесс аналогичен отправке веток — достаточно выполнить команду `git push origin <tagname>`

```
git push origin v1.5
```

Если у вас много тегов, и вам хотелось бы отправить все за один раз, то можно использовать опцию ` --tags` для команды `git push`

```
git push origin --tags
```

Теперь, если кто-то клонирует (`clone`) или выполнит `git pull` из вашего репозитория, то он получит вдобавок к остальному и ваши метки.        
Команда `git push` отправляет оба типа тегов.      
Отправка тегов командой `git push <remote> --tags` не различает аннотированные и легковесные теги.

### Удаление тегов
Для удаления тега в локальном репозитории достаточно выполнить команду `git tag -d <tagname>`. Например, удалить созданный ранее легковесный тег можно следующим образом:

```
git tag -d v1.4-lw
Deleted tag 'v1.4-lw' (was e7d5add)
```
Обратите внимание, что при удалении тега не происходит его удаления с внешних серверов. Существует два способа изъятия тега из внешнего репозитория.
***Первый способ*** — это выполнить команду `git push <remote> :refs/tags/<tagname>`

```
git push origin :refs/tags/v1.4-lw
  To /git@github.com:schacon/simplegit.git
   - [deleted]         v1.4-lw
```

Это следует понимать как обновление внешнего тега пустым значением, что приводит к его удалению.    
***Второй способ*** убрать тег из внешнего репозитория более интуитивный: 

```
git push origin --delete <tagname>
```

### Переход на тег
Если вы хотите получить версии файлов, на которые указывает тег, то вы можете сделать `git checkout` для тега. Однако, это переведёт репозиторий в состояние «`detached HEAD`», которое имеет ряд неприятных побочных эффектов.

```
git checkout v2.0.0
Note: switching to 'v2.0.0'.
```

Если в состоянии «`detached HEAD`» внести изменения и сделать коммит, то тег не изменится, при этом новый коммит не будет относиться ни к какой из веток, а доступ к нему можно будет получить только по его хешу. Поэтому, если вам нужно внести изменения — исправить ошибку в одной из старых версий — скорее всего вам следует создать ветку:

```
git checkout -b version2 v2.0.0
Switched to a new branch 'version2'
```
Если сделать коммит в ветке `version2`, то она сдвинется вперед и будет отличаться от тега `v2.0.0`, так что будьте с этим осторожны.

### Псевдонимы в Git (aliases)
Git не будет пытаться сделать вывод о том, какую команду вы хотели ввести, если вы ввели её не полностью. Если вы не хотите печатать каждую команду для Git целиком, вы легко можете настроить ***псевдонимы (alias)*** для любой команды с помощью `git config`. Вот несколько примеров псевдонимов:

```
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
```
Это означает, что, например, вместо ввода `git commit`, вам достаточно набрать только `git ci`. 

Обычно, добавляют команду `last` следующим образом:

```
git config --global alias.last 'log -1 HEAD'
```

Таким образом, можно легко просмотреть последний коммит:

```
git last
```

Git просто заменяет эти команды на созданные вами псевдонимы (`alias`). Однако, возможно, вы захотите выполнить внешнюю команду, а не подкоманду Git. В этом случае, следует начать команду с символа ` ! `. Это полезно, если вы пишете свои утилиты для работы с Git-репозиторием.

## Ветвление в Git
Используя ветвление, вы отклоняетесь от основной линии разработки и продолжаете работу независимо от неё, не вмешиваясь в основную линию.

Ветка в Git — это простой перемещаемый указатель на один из таких коммитов. По умолчанию, имя основной ветки в Git — `master or main`. Как только вы начнёте создавать коммиты, ветка `master` будет всегда указывать на последний коммит. Каждый раз при создании коммита указатель ветки `master` будет передвигаться на следующий коммит автоматически.

Ветка `master` в Git — это не какая-то особенная ветка. Она точно такая же, как и все остальные ветки. Она существует почти во всех репозиториях только лишь потому, что её создаёт команда `git init`, а большинство людей не меняют её название.

### Создание новой ветки
Что же на самом деле происходит при создании ветки? Всего лишь создаётся новый указатель для дальнейшего перемещения. Допустим вы хотите создать новую ветку с именем `testing`. Вы можете это сделать командой `git branch` :

```
git branch testing
```


Как Git определяет, в какой ветке вы находитесь? Он хранит специальный указатель `HEAD`. В Git — это ***указатель на текущую локальную ветку***. В нашем случае мы все еще находимся в ветке `master`. Команда `git branch` только создаёт новую ветку, но не переключает на неё.

Вы можете легко это увидеть при помощи простой команды `git log`, которая покажет вам куда указывают указатели веток. Эта опция называется `—decorate`.

```
git log --oneline --decorate
f30ab (HEAD -> master, testing)
```

Здесь можно увидеть указывающие на коммит f30ab ветки: `master` и `testing`. 

## Переключение веток
Для переключения на существующую ветку выполните команду `git checkout`. Давайте переключимся на ветку `testing`:

```
git checkout testing
```

В результате указатель `HEAD` переместится на ветку `testing`.

`git log` не показывает все ветки по умолчанию
Если выполнить команду `git log` прямо сейчас, то в её выводе только что созданная ветка `testing` фигурировать не будет.    
Ветка никуда не исчезла; просто Git не знает, что именно она вас интересует, и выводит наиболее полезную по его мнению информацию. Другими словами, по умолчанию `git log` отобразит историю коммитов только для текущей ветки.      
Для просмотра истории коммитов другой ветки необходимо явно указать её имя: `git log testing` Чтобы посмотреть историю по всем веткам — выполните команду с дополнительным флагом: `git log --all`

***Переключение веток меняет файлы в рабочем каталоге***
Важно запомнить, что при переключении веток в Git происходит изменение файлов в рабочем каталоге. Если вы переключаетесь на старую ветку, то рабочий каталог будет выглядеть так же, как выглядел на момент последнего коммита в ту ветку. Если Git по каким-то причинам не может этого сделать — он не позволит вам переключиться вообще.

Для отображения истории коммитов, текущего положения указателей веток и истории ветвления выполните команду `git log --oneline --decorate --graph --all`

```
git log --oneline --decorate --graph --all
  * c2b9e (HEAD, master) Made other changes
  | * 87ab2 (testing) Made a change
  |/
  * f30ab Add feature #32 - ability to add new formats to the central interface
  * 34ac2 Fix bug #1328 - stack overflow under certain conditions
  * 98ca9 initial commit of my project
 ```
  
Ветка в Git — это простой файл, содержащий 40 символов контрольной суммы SHA-1 коммита, на который она указывает; поэтому операции с ветками являются дешёвыми с точки зрения потребления ресурсов или времени.

### Одновременное создание новой ветки и переключение на неё
Как правило, при создании новой ветки вы хотите сразу на неё переключиться — это можно сделать используя команду `git checkout -b <newbranchname>`    
Начиная с Git версии 2.23, вы можете использовать `git switch` вместо `git checkout`, чтобы:    
-Переключиться на существующую ветку: `git switch testing-branch`.         
-Создать новую ветку и переключиться на нее: `git switch -c new-branch`. Флаг `-c` означает создание, но также можно использовать полный формат: ` --create`.      
-Вернуться к предыдущей извлечённой ветке: `git switch - `

### Основы ветвления и слияния
Имейте в виду, что если рабочий каталог либо индекс содержат незафиксированные изменения, конфликтующие с веткой, на которую вы хотите переключиться, то Git не позволит переключить ветки. Лучше всего переключаться из чистого рабочего состояния проекта. Есть способы обойти это (припрятать изменения `stash` или добавить их в последний коммит `amend`), но об этом мы поговорим позже в разделе ***Припрятывание и очистка главы 7***

Чтобы выполнить слияние ветки `hotfix` с веткой `master` для включения изменений в продукт. Это делается командой `git merge`:

```
git checkout master
git merge hotfix
```

После внедрения исправления из ранее созданной ветки, нужно удалить ветку `hotfix`, потому что она больше не нужна — ветка `master` указывает на то же самое место. Для удаления ветки выполните команду `git branch` с параметром `-d`:

```
git branch -d hotfix
  Deleted branch hotfix (3a0874c)
```

### Основы слияния
Все, что нужно сделать — переключиться на ветку, ***в которую вы хотите включить изменения***, и выполнить команду `git merge`:

```
git checkout master
  Switched to branch 'master'
git merge iss53  
```

### Основные конфликты слияния
Иногда процесс не проходит гладко. Если вы изменили одну и ту же часть одного и того же файла по-разному в двух объединяемых ветках, Git не сможет их чисто объединить.

```
git merge iss53
  Auto-merging index.html
  CONFLICT (content): Merge conflict in index.html
  Automatic merge failed; fix conflicts and then commit the result.
```

Git не создал коммит слияния автоматически. Он остановил процесс до тех пор, ***пока вы не разрешите конфликт***. Чтобы в любой момент после появления конфликта увидеть, какие файлы не объединены, вы можете запустить `git status`:

```
git status
  On branch master
  You have unmerged paths.
    (fix conflicts and run "git commit")
  Unmerged paths:
    (use "git add <file>..." to mark resolution)
      both modified:      index.html
  no changes added to commit (use "git add" and/or "git commit -a")
```
Всё, где есть неразрешённые конфликты слияния, перечисляется как неслитое. В конфликтующие файлы Git добавляет специальные маркеры конфликтов, чтобы вы могли исправить их вручную. В вашем файле появился раздел, выглядящий примерно так:

```
<<<<<<< HEAD:index.html
  <div id="footer">contact : email.support@github.com</div>
  =======
  <div id="footer">
   please contact us at support@github.com
  </div>
  >>>>>>> iss53:index.html
```  
Это означает, что версия из `HEAD` (вашей ветки `master`, поскольку именно её вы извлекли перед запуском команды слияния) — это верхняя часть блока (всё, что над `=======`), а версия из вашей другой ветки `iss53` представлена в нижней части. Чтобы разрешить конфликт, придётся выбрать один из вариантов, либо объединить содержимое по-своему. Например, вы можете разрешить конфликт, заменив весь блок следующим:

```
<div id="footer">
  please contact us at email.support@github.com
</div>
```
В этом разрешении есть немного от каждой части, а строки `<<<<<<<`, `=======` и `>>>>>>>` полностью удалены. Разрешив каждый конфликт во всех файлах, запустите `git add` для каждого файла, чтобы отметить конфликт как решённый. Добавление файла в индекс означает для `Git`, что все конфликты в нём исправлены.
Если вы хотите использовать графический инструмент для разрешения конфликтов, можно запустить `git mergetool`, который проведет вас по всем конфликтам:

```
git mergetool
  This message is displayed because 'merge.tool' is not configured.
  See 'git mergetool --tool-help' or 'git help config' for more details.
  'git mergetool' will now attempt to use one of the following tools:
  opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge
  p4merge araxis bc3 codecompare vimdiff emerge
  Merging:
  index.html
  Normal merge conflict for 'index.html':
    {local}: modified file
    {remote}: modified file
  Hit return to start merge resolution tool (opendiff):
  ```
Cписок всех поддерживаемых инструментов представлен вверху после фразы `one of the following tools`. Просто введите название инструмента, который хотите использовать.    
Если вы считаете, что коммит слияния требует дополнительных пояснений — опишите как были разрешены конфликты и почему были применены именно такие изменения, если это не очевидно.

### Управление ветками
Команда `git branch` делает несколько больше, чем просто создаёт и удаляет ветки. При запуске без параметров, вы получите простой список имеющихся у вас веток:

```
git branch
    iss53
  * master
    testing
```

Обратите внимание на символ ` * `, стоящий перед веткой `master`: он указывает на ветку, на которой вы находитесь в настоящий момент (т. е. ветку, на которую указывает `HEAD`). Это означает, что если вы сейчас сделаете коммит, ветка `master` переместится вперёд в соответствии с вашими последними изменениями. Чтобы посмотреть последний коммит на каждой из веток, выполните команду `git branch -v`:

```
git branch -v
    iss53   93b412c Fix javascript issue
  * master  7a98805 Merge branch 'iss53'
    testing 782fd34 Add scott to the author list in the readme
```

Опции ` --merged ` и ` --no-merged ` могут отфильтровать этот список для вывода только тех веток, которые слиты или ещё не слиты в текущую ветку. Чтобы посмотреть те ветки, ***которые вы уже слили с текущей***, можете выполнить команду `git branch --merged `:

```
git branch --merged
    iss53
  * master
```

Ветка iss53 присутствует в этом списке потому что вы ранее слили её в `master`. Те ветки из этого списка, перед которыми нет символа ` * `, можно смело удалять командой `git branch -d`; наработки из этих веток уже включены в другую ветку, так что ничего не потеряется.
Чтобы увидеть все ветки, содержащие наработки, которые вы пока ещё ***не слили в текущую ветку***, выполните команду `git branch --no-merged`:

```
git branch --no-merged
    testing
```

Вы увидите оставшуюся ветку. Так как она содержит ещё не слитые наработки, попытка удалить её командой `git branch -d` приведёт к ошибке:

```
git branch -d testing
  error: The branch 'testing' is not fully merged.
  If you are sure you want to delete it, run 'git branch -D testing'.
```
Если вы действительно хотите удалить ветку вместе со всеми наработками, используйте опцию ` -D `, как указано в подсказке.

Если в качестве аргумента не указан коммит или ветка, то опции ` --merged ` и ` --no-merged ` покажут что уже слито или не слито с вашей текущей веткой соответственно.
Вы всегда можете указать дополнительный аргумент для вывода той же информации, но относительно указанной ветки предварительно не извлекая и не переходя на неё.

```
git checkout testing
git branch --no-merged master
             topicA
             featureB
```

### Переименование ветки
Не переименовывайте ветки, которые всё ещё используются другими участниками.     
Предположим, у вас есть ветка с именем `bad-branch-name`, и вы хотите изменить её на `corrected-branch-name`, сохранив при этом всю историю. Вместе с этим, вы также хотите изменить имя ветки на удалённом сервере (GitHub, GitLab или др сервер). Как это сделать?

Переименуйте ветку локально с помощью команды `git branch --move`: 

```
git branch --move bad-branch-name corrected-branch-name
```
Ветка `bad-branch-name` будет переименована в `corrected-branch-name`, но это изменение пока только локальное. Чтобы все остальные увидели исправленную ветку в удалённом репозитории, отправьте её туда:

```
git push --set-upstream origin corrected-branch-name
```

Теперь проверим, где мы сейчас находимся:

```
git branch --all
  * corrected-branch-name
    main
    remotes/origin/bad-branch-name
    remotes/origin/corrected-branch-name
    remotes/origin/main
```
Обратите внимание, что текущая ветка `corrected-branch-name`, которая также присутствует и на удалённом сервере. Однако, старая ветка всё ещё по-прежнему там, но её можно удалить с помощью команды:

```
git push origin --delete bad-branch-name
```

### Изменение имени главной ветки
Переименуйте локальную ветку `master` в `main` с помощью следующей команды: 
```
git branch --move master main
```

Чтобы все остальные могли видеть новую ветку `main`, вам нужно отправить её в общий репозиторий. Это делает переименованную ветку доступной в удалённом репозитории.

```
git push --set-upstream origin main
```
В итоге, состояние репозитория становится следующим:

```
git branch --all
  * main
    remotes/origin/HEAD -> origin/master
    remotes/origin/main
    remotes/origin/master
```

Ваша локальная ветка `master` исчезла, так как она заменена веткой `main`. Ветка `main` доступна в удалённом репозитории. Старая ветка `master` всё ещё присутствует в удалённом репозитории. Остальные участники будут продолжать использовать ветку `master` в качестве основы для своей работы, пока вы не совершите ряд дополнительных действий.
Теперь, для завершения перехода на новую ветку перед вами стоят следующие задачи:     

• Все проекты, которые зависят от текущего, должны будут обновить свой код и/или конфигурацию.

• Обновите конфигурацию всех запускаемых тестов.

• Исправьте скрипты сборки и публикации артефактов.

• Поправьте настройки репозитория на сервере: задайте новую ветку по умолчанию, обновите правила слияния, а также прочие настройки, которые зависят от имени веток.

• Обновите документацию, исправив ссылки, указывающие на старую ветку.

• Слейте или отмените запросы на слияние изменений, нацеленные на старую ветку.

После того, как вы выполнили все эти задачи и уверены, что ветка `main` работает так же, как ветка `master`, вы можете удалить ветку `master`:

```
git push origin --delete master
```
  
### Работа с ветками
### Долгоживущие ветки
Идея состоит в том, что каждая ветка представляет собой определённый уровень стабильности; как только он повышается, содержимое сливается в ветку уровнем выше.

### Тематические ветки
Так называется временная ветка, создаваемая и используемая для работы над конкретной функциональной возможностью или решения сопутствующих задач.

### Удалённые ветки
`origin` — это не специальное название.   
Подобно названию ветки `master`, `origin` не имеет какого-либо специального значения в Git. В то время как `master` — это название по умолчанию для ветки при выполнении `git init` только потому, что часто используется, `origin` — это название по умолчанию для удалённого сервера, когда вы запускаете `git clone`. Если вы выполните `git clone -o newname`, то по умолчанию ветка слежения будет иметь вид `newname/master`.

Для синхронизации ваших изменений с удаленным сервером выполните команду `git fetch <remote>` (в нашем случае `git fetch origin`). Эта команда определяет какому серверу соответствует `origin` (в нашем случае это git.ourcompany.com), извлекает оттуда данные, которых у вас ещё нет, и обновляет локальную базу данных, сдвигая указатель `origin/master` на новую позицию.

### Отправка изменений
Когда вы хотите поделиться веткой, вам необходимо отправить её на удалённый сервер, где у вас есть права на запись. Ваши локальные ветки автоматически не синхронизируются с удалёнными при отправке — вам нужно явно указать те ветки, которые вы хотите отправить. Таким образом, вы можете использовать свои личные ветки для работы, которую не хотите показывать, а отправлять только те тематические ветки, над которыми вы хотите работать с кем-то совместно.
Если у вас есть ветка `serverfix`, над которой вы хотите работать с кем-то ещё, вы можете отправить её точно так же, как вы отправляли вашу первую ветку. Выполните команду `git push <remote> <branch>`:

```
git push origin serverfix
```

### Отслеживание веток
Получение локальной ветки из удалённой ветки автоматически создаёт то, что называется `веткой слежения` (а ветка, за которой следит локальная называется `upstream branch`). Ветки слежения — это локальные ветки, которые напрямую связаны с удалённой веткой. Если, находясь на ветке слежения, выполнить `git pull`, то Git уже будет знать с какого сервера получать данные и какую ветку использовать для слияния.

При клонировании репозитория, как правило, автоматически создаётся ветка `master`, которая следит за `origin/master`. Однако, при желании вы можете настроить отслеживание и других веток — следить за ветками на других серверах или отключить слежение за веткой `master`. Вы только что видели простейший пример, что сделать это можно с помощью команды `git checkout -b <branch> <remote>/<branch>`. Это часто используемая команда, поэтому Git предоставляет сокращённую форму записи в виде флага  ` --track `:

```
git checkout --track origin/serverfix
  Branch serverfix set up to track remote branch serverfix from origin.
  Switched to a new branch 'serverfix'
```
В действительности, это настолько распространённая команда, что существует сокращение для этого сокращения. Если вы пытаетесь извлечь ветку, которая не существует, но существует только одна удалённая ветка с точно таким же именем, то Git автоматически создаст ветку слежения:

```
git checkout serverfix
  Branch serverfix set up to track remote branch serverfix from origin.
  Switched to a new branch 'serverfix'
```
Чтобы создать локальную ветку с именем, отличным от имени удалённой ветки, просто укажите другое имя:
```
git checkout -b newname origin/serverfix
  Branch sf set up to track remote branch serverfix from origin.
  Switched to a new branch 'newname'
```
Теперь ваша локальная ветка `newname` будет автоматически получать изменения из `origin/serverfix`.

Если у вас уже есть локальная ветка и вы хотите настроить ее на слежение за удалённой веткой, которую вы только что получили, или хотите изменить используемую upstream-ветку, то воспользуйтесь параметрами `-u` или ` --set-upstream-to ` для команды `git branch`, чтобы явно установить новое значение.

```
git branch -u origin/serverfix
  Branch serverfix set up to track remote branch serverfix from origin.
```

#### Сокращение Upstream
Если у вас настроена отслеживаемая ветка, вы можете ссылаться на нее с помощью сокращений `@{upstream}` или `@{u}`. Итак, если вы находитесь на ветке master и она следит за `origin/master`, при желании вы можете использовать `git merge @{u}` вместо `git merge origin/master`.

Если вы хотите посмотреть как у вас настроены ветки слежения, воспользуйтесь опцией ` -vv ` для команды `git branch`. Это выведет список локальных веток и дополнительную информацию о том, какая из веток отслеживается, отстаёт, опережает или всё сразу относительно отслеживаемой.

```
git branch -vv
    iss53     7e424c3 [origin/iss53: ahead 2] Add forgotten brackets
    master    1ae2a45 [origin/master] Deploy index fix
  * serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] This should do it
    testing   5ea463a Try something new
```

Итак, здесь мы видим, что наша ветка `iss53` следит за `origin/iss53` и «опережает» её на два изменения — это значит, что у нас есть два локальных коммита, которые не отправлены на сервер. Мы также видим, что наша ветка `master` отслеживает ветку `origin/master` и находится в актуальном состоянии. Далее мы можем видеть, что локальная ветка `serverfix` следит за веткой `server-fix-good` на сервере `teamone`, опережает её на три коммита и отстает на один — это значит, что на сервере есть один коммит, который мы ещё не слили, и три локальных коммита, которые ещё не отправлены на сервер. В конце мы видим, что наша ветка `testing` не отслеживает удаленную ветку.

Важно отметить, что эти цифры описывают состояние на момент последнего получения данных с каждого из серверов. Эта команда не обращается к серверам, а лишь говорит вам о том, какая информация с этих серверов сохранена в локальном кэше. Если вы хотите иметь актуальную информацию об этих числах, вам необходимо получить данные со всех ваших удалённых серверов перед запуском команды. Сделать это можно вот так:

```
git fetch --all; git branch -vv
```

### Получение изменений
Команда `git fetch` получает с сервера все изменения, которых у вас ещё нет, но не будет изменять состояние вашей рабочей копии. Эта команда просто получает данные и позволяет вам самостоятельно сделать слияние. Тем не менее, существует команда `git pull`, которая в большинстве случаев является командой `git fetch`, за которой непосредственно следует команда `git merge`. Если у вас настроена ветка слежения как показано в предыдущем разделе, или она явно установлена, или она была создана автоматически командами `clone` или `checkout`, `git pull` определит сервер и ветку, за которыми следит ваша текущая ветка, получит данные с этого сервера и затем попытается слить удалённую ветку.
Обычно, лучше явно использовать команды `fetch` и `merge`, поскольку магия `git pull` может часто сбивать с толку.

### Удаление веток на удалённом сервере
Скажем, вы и ваши соавторы закончили с нововведением и слили его в ветку `master` на удалённом сервере (или в какую-то другую ветку, где хранится стабильный код). Вы можете удалить ветку на удалённом сервере используя параметр ` --delete ` для команды `git push`. Для удаления ветки `serverfix` на сервере, выполните следующую команду:

```
git push origin --delete serverfix
  To https://github.com/schacon/simplegit
   - [deleted]         serverfix
```
Всё, что делает эта строка — удаляет указатель на сервере. Как правило, Git сервер хранит данные пока не запустится сборщик мусора, поэтому если ветка была удалена случайно, чаще всего её легко восстановить.

### Перебазирование
В Git есть два способа внести изменения из одной ветки в другую: ***слияние и перебазирование***.

С помощью команды rebase вы можете взять все коммиты из одной ветки и в том же порядке применить их к другой ветке поверх.    
В данном примере переключимся на ветку `experiment` и перебазируем её относительно ветки `master` следующим образом:

```
git checkout experiment
git rebase master
  First, rewinding head to replay your work on top of it...
  Applying: added staged command
```

Это работает следующим образом: берётся общий родительский снимок двух веток (текущей, и той, поверх которой вы выполняете перебазирование), определяется дельта каждого коммита текущей ветки и сохраняется во временный файл, текущая ветка устанавливается на последний коммит ветки, поверх которой вы выполняете перебазирование, а затем по очереди применяются дельты из временных файлов.

После этого вы можете переключиться обратно на ветку master и выполнить слияние перемоткой.

```
git checkout master
git merge experiment
```

Перебазирование делает историю коммитов чище. Если вы взглянете на историю перебазированной ветки, то увидите, что она выглядит абсолютно линейной: будто все операции были выполнены последовательно, даже если изначально они совершались параллельно в разных ветках.

Часто вы будете делать так для уверенности, что ваши коммиты могут быть бесконфликтно слиты в удалённую ветку — возможно, в проекте, куда вы пытаетесь внести вклад, но владельцем которого вы не являетесь. В этом случае вам следует работать в своей ветке и затем перебазировать вашу работу поверх origin/master, когда вы будете готовы отправить свои изменения в основной проект. Тогда владельцу проекта не придётся делать никакой лишней работы — всё решится простой перемоткой или бесконфликтным слиянием.

Учтите, что снимок, на который ссылается ваш последний коммит — является ли он последним коммитом после перебазирования или коммитом слияния после слияния — в обоих случаях это один и тот же снимок, отличаются только истории коммитов. ***Перебазирование повторяет изменения из одной ветки поверх другой в том порядке, в котором эти изменения были сделаны, в то время как слияние берет две конечные точки и сливает их вместе.***

### Опасности перемещения
Но даже перебазирование, при всех своих достоинствах, не лишено недостатков, которые можно выразить одной строчкой:      
***Не перемещайте коммиты, уже отправленные в публичный репозиторий***

Если вы рассматриваете перебазирование как способ наведения порядка и работаете с коммитами локально до их отправки или ваши коммиты никогда не будут доступны публично — у вас всё будет хорошо. Однако, если вы перемещаете коммиты, отправленные в публичный репозиторий, и есть вероятность, что работа некоторых людей основывается на этих коммитах, то ваши действия могут вызвать существенные проблемы, а вы — вызвать презрение вашей команды.

### Перемещение vs. Слияние
История коммитов в вашем репозитории — это запись того, что на самом деле произошло. Это исторический документ, ценный сам по себе, и его нельзя подделывать. С этой точки зрения изменение истории коммитов практически кощунственно; вы лжёте о том, что на самом деле произошло. 

Противоположная точка зрения заключается в том, что история коммитов — это история того, как был сделан ваш проект. Вы не публикуете первый черновик книги или инструкции по поддержке вашего программного обеспечения, так как это нуждается в тщательном редактировании. Сторонники этого лагеря считают использование инструментов `rebase` и `filter-branch` способом рассказать историю проекта наилучшим образом для будущих читателей.

## Git на сервере
### Протоколы
Git умеет работать с четырьмя сетевыми протоколами для передачи данных: ***локальный, HTTP, Secure Shell (SSH) и Git***.

### Локальный протокол
Если у вас смонтирована общая файловая система, вы можете клонировать, отправлять и получать изменения из локального репозитория. Чтобы клонировать такой репозиторий или добавить его в качестве удалённого в существующий проект, используйте путь к репозиторию в качестве URL. Например, для клонирования локального репозитория вы можете выполнить что-то вроде этого:

```
git clone /srv/git/project.git
```
   Или этого:
   
```
git clone file:///srv/git/project.git
```
 
Чтобы добавить локальный репозиторий в существующий проект, вы можете воспользоваться командой:

```
git remote add local_proj /srv/git/project.git
```
Недостаток этого метода в том, что общий доступ обычно сложнее настроить и получить из разных мест, чем простой сетевой доступ.

### Протоколы HTTP
Новая версия часто называется ***Умным (Smart) HTTP***, а старая ***Тупым (Dumb) HTTP***. Сначала мы рассмотрим Умный протокол.

### Умный HTTP
Умный протокол HTTP поверх стандартных HTTP/S портов и может использовать различные механизмы аутентификации HTTP, это часто проще для пользователя, чем что-то вроде SSH, так как можно использовать аутентификацию по логину/паролю вместо установки SSH-ключей.
Наверное, сейчас он стал наиболее популярным способом использования Git, так как может использоваться и для анонимного доступа как протокол git://, и для отправки изменений с аутентификацией и шифрованием как протокол SSH. Вместо использования разных адресов URL для этих целей, можно использовать один URL адрес для всего. Если вы пытаетесь отослать изменения и репозиторий требует аутентификации (обычно так и есть), сервер может спросить логин и пароль. То же касается и доступа на чтение.
На самом деле для сервисов вроде GitHub, адрес URL, который вы используете для просмотра репозитория в браузере (например, https://github.com/schacon/simplegit), можно использовать для клонирования или, если у вас есть доступ, для отправки изменений.

### Тупой HTTP
Если сервер не отвечает на умный запрос Git по HTTP, клиент Git попытается откатиться на более простой Тупой HTTP-протокол. Тупой протокол ожидает, что голый репозиторий Git будет обслуживаться веб-сервером как набор файлов

Прелесть тупого протокола HTTP — в простоте настройки. По сути, всё, что необходимо сделать — поместить голый репозиторий
в корневой каталог HTTP и установить обработчик `post-update` (смотри Хуки в Git). Теперь каждый может клонировать репозиторий, если имеет доступ к веб-серверу, на котором он был размещен. Таким образом, чтобы открыть доступ на чтение к вашему репозиторию посредством HTTP, нужно сделать что-то наподобие этого:
```
cd /var/www/htdocs/
git clone --bare /path/to/git_project gitproject.git
cd gitproject.git
mv hooks/post-update.sample hooks/post-update
chmod a+x hooks/post-update
```
Вот и всё. Обработчик `post-update`, входящий в состав Git по умолчанию, выполняет необходимую команду (`git update-server-info`), чтобы получение изменений и клонирование по HTTP работали правильно. Эта команда выполняется, когда вы отправляете изменения в репозиторий (возможно посредством SSH); затем остальные могут клонировать его командой

```
git clone https://example.com/gitproject.git
```

### Протокол SSH
Часто используемый транспортный протокол для самостоятельного хостинга Git — это `SSH`. SSH — протокол с аутентификацией.      
Чтобы клонировать Git-репозиторий по SSH, вы можете указать префикс `ssh://` в URL, например:

```
git clone ssh://[user@]server/project.git
```
Или можно использовать для протокола SSH краткий синтаксис наподобие scp: 

```
git clone [user@]server:project.git
```
Также вы можете не указывать имя пользователя, Git будет использовать то, под которым вы вошли в систему. 

### Git-протокол
Следующий протокол — Git-протокол. Вместе с Git поставляется специальный демон, который слушает отдельный порт `9418` и предоставляет сервис, схожий с протоколом `SSH`, но абсолютно без аутентификации. Чтобы использовать Git-протокол для репозитория, вы должны создать файл `git-export-daemon-ok`, иначе демон не будет работать с этим репозиторием, но следует помнить, что в протоколе ***отсутствуют средства безопасности***. Соответственно, любой репозиторий в Git может быть либо доступен для клонирования всем, либо нет. Как следствие, обычно отправлять изменения по этому протоколу нельзя. Вы можете открыть доступ на запись, но из-за отсутствия аутентификации в этом случае кто угодно, зная URL вашего проекта, сможет его изменить. В общем, это редко используемая возможность.    
    
***Достоинства***       
Git-протокол ― часто самый быстрый из доступных протоколов. Если у вас проект с публичным доступом и большой трафик, или у вас очень большой проект, для которого не требуется аутентификация пользователей для чтения, вам стоит настроить демон Git для вашего проекта. Он использует тот же механизм передачи данных, что и протокол SSH, но без дополнительных затрат на шифрование и аутентификацию.      
       
***Недостатки***      
Недостатком Git-протокола является отсутствие аутентификации

## Распределенный Git
### Распределенный рабочий процесс
### Централизованная работа
Центральный хаб или репозиторий может принимать код, а все остальные синхронизируют свою работу с ним. Все разработчики являются узлами (пользователями хаба) и синхронизируются только с ним.

Это означает, что если два разработчика клонируют репозиторий и каждый внесёт изменения, то первый из них сможет отправить свои изменения в репозиторий без проблем. Второй разработчик должен слить изменения, сделанные первым разработчиком, чтобы избежать их перезаписи во время отправки на сервер.

Достаточно создать один репозиторий и предоставить каждому члену команды `push-доступ`; Git не позволит перезаписать изменения, сделанные другими.   

Предположим, Джон и Джессика начинают работать над проектом одновременно. Джон вносит изменения и отправляет их на сервер. Затем Джессика пытается отправить свои изменения, но сервер их отклоняет. Ей говорят, что она пытается отправить изменения, для которых невозможно выполнить быструю перемотку и она не сможет это сделать пока не получит все новые для неё изменения и не сольёт их. Такой рабочий процесс привлекает большинство людей, так как реализует парадигму, с которой они уже знакомы.
Такой подход применим не только к небольшим командам. Используя модель ветвления Git, сотни разработчиков могут одновременно работать над одним проектом, используя при этом десятки веток.

### Диспетчер интеграции
Так как Git допускает использование нескольких удалённых репозиториев, то становится возможным организация рабочего процесса, где каждый разработчик имеет доступ на запись в свой публичный репозиторий и доступ на чтение ко всем остальным. При таком сценарии обычно существует канонический репозиторий, который представляет собой `официальный` проект. Для отправки своих наработок в этот проект следует создать его клон и отправить изменения в него. Затем вы отправляете запрос на слияние ваших изменений сопровождающему основного проекта. В свою очередь он может добавить ваш репозиторий как удаленный, протестировать ваши изменения локально, слить их в соответствующую ветку и отправить в основной репозиторий. 

Процесс работает в следующей последовательности:
1. Сопровождающий проекта отправляет изменения в свой публичный репозиторий.
2. Участник клонирует этот репозиторий и вносит изменения.
3. Участник отправляет свои изменения в свой публичный репозиторий.
4. Участник отправляет письмо сопровождающему с запросом на слияние изменений.
5. Сопровождающий добавляет репозиторий участника как удалённый и сливает изменения локально.
6. Сопровождающий отправляет слитые изменения в основной репозиторий.

### Диктатор и помощники
Это вариант организации рабочего процесса с использованием нескольких репозиториев. В основном такой подход используется на огромных проектах, насчитывающих сотни участников; самый известный пример — ядро Linux. ***Помощники (lieutenants)*** — это интеграционные менеджеры, которые отвечают за отдельные части репозитория. Над ними главенствует один диспетчер интеграции, которого называют великодушным ***диктатором***.       Репозиторий диктатора выступает как эталонный (blessed), откуда все участники процесса должны получать изменения. Процесс работает следующим образом:
1. Обычные разработчики работают в своих тематических ветках и перебазируют свою работу относительно ветки `master`. Ветка `master` — это ветка эталонного репозитория в которую имеет доступ только диктатор.
2. Помощники сливают тематические ветки разработчиков в свои ветки `master`
3. Диктатор сливает ветки `master` помощников в свою ветку `master`.
4. Наконец, диктатор отправляет свою ветку `master` в эталонный репозиторий, чтобы все остальные могли перебазировать свою работу на основании неё.

### Участие в проекте
### Правила создания коммитов
Для начала, вам не следует отправлять ненужные пробелы. Git предоставляет простой способ проверки — перед коммитом выполните команду `git diff --check`, которая выведет список ненужных пробелов.

Пишите сообщение коммита в императиве: «Fix bug» а не «Fixed bug» или «Fixes bug».

Вот шаблон хорошего сообщения коммита:

```
Краткое (не более 50 символов) резюме с заглавной буквы
Более детальный, поясняющий текст, если он требуется.     
Старайтесь не превышать длину строки в 72 символа.        
В некоторых случаях первая строка подразумевается как тема письма, а всё остальное -- как тело письма.        
Пустая строка, отделяющая сводку от тела, имеет решающее 
значение (за исключением случаев, когда детального описания 
нет); в противном случае такие инструменты, как rebase, могут 
вас запутать.      

Сообщения коммитов следует писать используя неопределенную форму глагола совершенного вида
повелительного наклонения: «Fix bug» (Исправить баг).
Это соглашение соответствует сообщениям коммитов, 
генерируемых такими командами, как `git merge` и `git revert`.

Последующие абзацы идут после пустых строк.

- Допускаются обозначения пунктов списка

- Обычно, элементы списка обозначаются с помощью тире или звёздочки, с одним пробелом перед ними, а 
разделяются пустой строкой, но соглашения могут отличаться

- Допускается обратный абзацный отступ.
```

### Небольшая команда
Давайте посмотрим что происходит, когда два разработчика начинают работать вместе и используют общий репозиторий. Первый разработчик Джон клонирует репозиторий, вносит изменения и делает коммит локально. (В последующих примерах сообщения протокола заменены на ... с целью их немного сократить.)

```
# Компьютер Джона
git clone john@githost:simplegit.git
Cloning into 'simplegit'...
...
cd simplegit/
vim lib/simplegit.rb
git commit -am 'Remove invalid default value' [master 738ee87] Remove invalid default value
   1 files changed, 1 insertions(+), 1 deletions(-)
```
Второй разработчик Джессика делает то же самое — клонирует репозиторий и делает коммит:

```
# Компьютер Джессики
git clone jessica@githost:simplegit.git Cloning into 'simplegit'...
...
cd simplegit/
vim TODO
git commit -am 'Add reset task'
[master fbff5bc] Add reset task
   1 files changed, 1 insertions(+), 0 deletions(-)
```  
Затем Джессика отправляет изменения на сервер:

```
# Компьютер Джессики
git push origin master
...
To jessica@githost:simplegit.git
     1edee6b..fbff5bc  master -> master
```

Джон вносит некоторые изменения, делает коммит и пытается отправить его на тот же сервер:

```
# Компьютер Джона
git push origin master
To john@githost:simplegit.git
   ! [rejected]        master -> master (non-fast forward)
  error: failed to push some refs to 'john@githost:simplegit.git'
```

В данном случае изменения Джона отклонены, так как Джессика уже отправила свои. В Git вы должны сначала слить изменения локально. Джон должен получить изменения Джессики и слить их локально, прежде чем сможет отправить свои.
Для начала, Джон получает изменения Джессики (слияния изменений пока что не происходит):

```
git fetch origin
  ...
  From john@githost:simplegit
   + 049d078...fbff5bc master     -> origin/master
```

Теперь Джон может слить полученные изменения Джессики со своей локальной веткой:
Процесс слияния проходит гладко 

```
git merge origin/master
  Merge made by the 'recursive' strategy.
   TODO |    1 +
   1 files changed, 1 insertions(+), 0 deletions(-)
```

Теперь Джон может протестировать новый код, чтобы убедиться в корректной работе объединённых изменений, после чего он может отправить объединённые изменения на сервер:

```
git push origin master
  ...
  To john@githost:simplegit.git
     fbff5bc..72bbc59  master -> master
```

Тем временем Джессика создала тематическую ветку с названием `issue54` и сделала в ней три коммита. Она ещё не получила изменения Джона. Внезапно Джессика узнаёт, что Джон отправил какие-то изменения на сервер и теперь она хочет на них взглянуть; для этого ей следует получить с сервера все новые изменения:

```
# Компьютер Джессики
$ git fetch origin
...
From jessica@githost:simplegit
     fbff5bc..72bbc59  master     -> origin/master
```
Это приводит к получению изменений, отправленных Джоном в репозиторий 

Джессика считает, что её тематическая ветка готова, но так же хочет знать какие изменения следует слить со своей работой перед отправкой на сервер. Для прояснения ситуации он выполняет команду `git log`:

```
git log --no-merges issue54..origin/master
  commit 738ee872852dfaa9d6634e0dea7a324040193016
  Author: John Smith <jsmith@example.com>
  Date:   Fri May 29 16:01:27 2009 -0700
     Remove invalid default value
```

`issue54..origin/master` — это синтаксис фильтра, который указывает Git отображать только список коммитов, которые существуют в последней ветке (в данном случае `origin/master`), но отсутствуют в первой (в данном случае `issue54`). Более детально этот синтаксис рассматривается в разделе Диапазоны коммитов главы 7.

В данном случае, в выводе команды мы видим только один коммит, сделанный Джоном и ещё не слитый Джессикой. Если она сольёт `origin/master`, то это будет единственный коммит, который изменит локальное состояние.

Теперь, Джессика может слить изменения тематической ветки и изменения Джона (`origin/master`) в свою локальную ветку `master`, а затем отправить её на сервер.       
Для начала (при условии отсутствия изменений в тематической ветке, не включённых в коммит), Джессика переключается на свою ветку `master`:

```
git checkout master
  Switched to branch 'master'
  Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
```

Обе ветки `origin/master` и `issue54` являются отслеживаемыми, поэтому порядок слияния не важен. Конечный результат будет идентичным вне зависимости от порядка слияния, однако история коммитов будет немного отличаться. Джессика решает слить ветку `issue54` первой:





 